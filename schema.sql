-- 
-- TABLES
-- 
CREATE TABLE public.new_session (
    id character varying PRIMARY KEY NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

CREATE TABLE public.playlist (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,

    user_id uuid REFERENCES auth.users NOT NULL DEFAULT auth.uid(),

    name text NOT NULL,
    users uuid[]
);

CREATE TABLE public.session (
    id character varying PRIMARY KEY NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,

    user_id uuid REFERENCES auth.users NOT NULL DEFAULT auth.uid(),

    playlist bigint REFERENCES public.playlist NOT NULL,
    currently_playing bigint REFERENCES public.song
);

CREATE TABLE public.song (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,

    added_by uuid REFERENCES auth.users NOT NULL DEFAULT auth.uid(),

    play_count smallint DEFAULT '0'::smallint NOT NULL,
    platform_id character varying NOT NULL,
    playlist bigint NOT NULL,
    title character varying NOT NULL,
    song_type character varying NOT NULL,

    artist character varying,
    album character varying,
    length bigint,
    cover character varying
);

-- 
-- COMMENTS
-- 
COMMENT ON TABLE public.playlist IS 'Table that holds all playlists';
COMMENT ON TABLE public.song IS 'Table that holds all song information';
COMMENT ON TABLE public.session IS 'Table that holds session information';
COMMENT ON TABLE public.new_session IS 'Table that holds information about session that are not instansiated yet, but do have a session code';

-- 
-- ROW LEVEL SECURITY 
-- 

ALTER TABLE public.song ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.playlist ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.session ENABLE ROW LEVEL SECURITY;

-- 
-- POLICIES
-- 

-- PLAYLIST
CREATE POLICY "Only users can create playlists" ON public.playlist 
    FOR INSERT WITH CHECK ((auth.role() = 'authenticated'::text));

CREATE POLICY "Users can only delete their own playlists" ON public.playlist 
    FOR DELETE USING ((auth.uid() = user_id));

-- SESSION
CREATE POLICY "Only users can claim a session" ON public.session
    FOR INSERT WITH CHECK ((auth.role() = 'authenticated'::text));

CREATE POLICY "Users can only make a session if that session also exists as a new session" ON public.session
    FOR INSERT WITH CHECK ((auth.role() = 'authenticated'::text) AND (SELECT id FROM public.new_session WHERE id = NEW.id));

-- NEW SESSION
CREATE POLICY "Only users can make a new session" ON public.new_session
    FOR INSERT WITH CHECK ((auth.role() = 'authenticated'::text));

-- SONG
CREATE POLICY "Only users can add songs" ON public.song
    FOR INSERT WITH CHECK ((auth.role() = 'authenticated'::text));

-- 
-- PL/pgSQL
-- 

-- Increment the play count of a song
CREATE OR REPLACE FUNCTION increment_play_count(song_id bigint) RETURNS void AS $$
    BEGIN
        UPDATE public.song
        SET play_count = play_count + 1
        WHERE id = song_id;
    END;
$$ LANGUAGE plpgsql;

-- Add user to the playlist as someone who has added the song
CREATE OR REPLACE FUNCTION add_user_to_playlist(playlist_id bigint, uid uuid) RETURNS void AS $$
    BEGIN
        UPDATE public.playlist
        SET users = array_append(users, uid)
        WHERE id = playlist_id
        AND uid != ANY(users);
    END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION claim_session(session_id character varying, user_id uuid, playlist_id bigint) RETURNS void AS $$ 
    BEGIN
        INSERT INTO public.session(id, user_id, playlist)
        VALUES (session_id, user_id, playlist_id);

        DELETE FROM public.new_session
        WHERE id = session_id;
    END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION new_session() RETURNS character varying as $$
    DECLARE
        session_id character varying;
    BEGIN
        LOOP
            session_id = random_string(4);
            EXIT WHEN NOT EXISTS (SELECT id FROM public.new_session WHERE id = session_id);
        END LOOP;
        
        INSERT INTO public.new_session(id)
        VALUES (session_id);


        RETURN session_id;
    END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION random_string(length integer) RETURNS character varying AS $$
    DECLARE
        r character varying;
    BEGIN
        r = array_to_string(array(select substr('ABCDEFGHKNPRSTUVXYZ',((random()*(19-1)+1)::integer),1) from generate_series(1,length)),'');
        RETURN r;
    END;
$$ LANGUAGE plpgsql;